7: Handling blocking work with threads
-----------------------
- can use multithreading with asyncio to run blocking apis

7.1: Introducing the threading module
-----------------------
- can create and manage threads via the threading module
    - exposes the Thread class, accepts function to run in a different thread
- I/O released GIL, so we can run IO in different threads concurrently
- exceptions are only thrown in the main thread
- can use daemon threads (long running background tasks)
- thread class has run method that we can override

7.2: Using threads with asyncio
-----------------------
- like process pools, there are also thread pools
- concurrent.futures provides an implementation of Executor abstract class to work for threads
    - called ThreadPoolExecutor
    - create and maintain pool of threads that we can submit work too
- default number of threads is determiend by min(32, os.cpu_count() + 4)
- can also use it with asyncio
- default executors are a reusable sigleton executor for you entire application
    - will always default to ThreadPoolExecutor but we can set a custom one
    - use loop.set_default_executor
    - if we set it to None, asycnio creates and caches a default thread pool executor for us
- in 3.9, asyncio.to_thread coroutine was introduced
    - takes a function to run in a thread and a set of arguments to pass to that functions
